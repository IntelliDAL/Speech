# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/101_models.ResNet.ipynb (unless otherwise specified).

__all__ = ['ResBlock', 'ResNet', 'CnnBlock']

# Cell
from ..imports import *
from .layers import *
from .utils import *


# Cell
class ResBlock(Module):
    def __init__(self, ni, nf, kss=[3, 3, 3]):
        self.convblock1 = ConvBlock(ni, nf, kss[0], separable=False)
        # self.convblock1 = ConvBlock(ni, nf, kss[0], dropout=0.1)
        self.convblock2 = ConvBlock(nf, nf, kss[1], separable=False)
        # self.convblock2 = ConvBlock(nf, nf, kss[1], dropout=0.1)
        self.convblock3 = ConvBlock(nf, nf, kss[2], act=None, separable=False)

        # expand channels for the sum if necessary
        self.shortcut = BN1d(ni) if ni == nf else ConvBlock(ni, nf, 1, act=None, separable=False)
        self.add = Add()
        self.act = nn.LeakyReLU(0.2)
        for m in self.modules():
            if isinstance(m, nn.Conv1d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')
            elif isinstance(m, (nn.BatchNorm1d, nn.GroupNorm)):
                nn.init.constant_(m.weight, 1)
                nn.init.constant_(m.bias, 0)

    def forward(self, x):
        res = x
        x = self.convblock1(x)
        x = self.convblock2(x)
        x = self.convblock3(x)
        x = self.add(x, self.shortcut(res))
        x = self.act(x)
        return x


class ResNet(Module):
    def __init__(self, c_in, c_out):
        nf = 32  # 根据merge后的大小设置通道
        self.resblock1 = ResBlock(c_in, nf)
        self.resblock2 = ResBlock(nf, nf * 2)
        self.resblock3 = ResBlock(nf * 2, nf * 2)
        self.gap = nn.AdaptiveAvgPool1d(1)
        self.squeeze = Squeeze(-1)
        self.fc = nn.Linear(nf * 2, c_out)
        self.dropout = nn.Dropout(0.25)  # 防止over-fitting

    def forward(self, x):
        x = self.resblock1(x)
        x = self.resblock2(x)
        x = self.resblock3(x)
        x = self.squeeze(self.gap(x))
        x = self.fc(x)
        x = self.dropout(x)
        return x


class ResNet_sup(Module):
    def __init__(self, c_in, c_out):
        self.nf = 32  # 根据merge后的大小设置通道
        self.resblock1 = ResBlock(c_in, self.nf)
        self.resblock2 = ResBlock(self.nf, self.nf * 2)
        self.resblock3 = ResBlock(self.nf * 2, self.nf * 2)
        self.gap = nn.AdaptiveAvgPool1d(1)
        self.squeeze = Squeeze(-1)

    def forward(self, x):
        x = self.resblock1(x)
        x = self.resblock2(x)
        x = self.resblock3(x)
        x = self.squeeze(self.gap(x))
        return x


class CnnBlock(Module):
    def __init__(self, c_in, c_out):
        self.resblock = ResBlock(c_in, c_out)

    def forward(self, x):
        x = self.resblock(x)
        return x
